import {nest} from "d3-collection";
import {configPrep, elem, merge} from "d3plus-common";

/**
    @function legendLabel
    @desc Default label function for the legend.
    @private
*/
export function legendLabel(d, i) {
  var l = this._drawLabel(d, i);
  return l instanceof Array ? l.join(", ") : l;
}

/**
    @function _drawLegend
    @desc Renders the legend if this._legend is not falsy.
    @param {Array} data The filtered data array to be displayed.
    @private
*/
export default function(data) {
  var this$1 = this;
  if ( data === void 0 ) data = [];


  if (this._legend) {

    var legendBounds = this._legendClass.outerBounds();
    var position = this._legendPosition;
    var wide = ["top", "bottom"].includes(position);

    var transform = {transform: ("translate(" + (wide ? this._margin.left + this._padding.left : this._margin.left) + ", " + (wide ? this._margin.top : this._margin.top + this._padding.top) + ")")};

    var legendGroup = elem("g.d3plus-viz-legend", {
      condition: this._legend && !this._legendConfig.select,
      enter: transform,
      parent: this._select,
      transition: this._transition,
      update: transform
    }).node();

    var legendData = [];

    var color = function (d, i) {
      var shape = this$1._shape(d, i);
      var attr = shape === "Line" ? "stroke" : "fill";
      var value = this$1._shapeConfig[shape] && this$1._shapeConfig[shape][attr]
        ? this$1._shapeConfig[shape][attr] : this$1._shapeConfig[attr];
      return typeof value === "function" ? value(d, i) : value;
    };

    var opacity = function (d, i) {
      var shape = this$1._shape(d, i);
      var value = this$1._shapeConfig[shape] && this$1._shapeConfig[shape].opacity
        ? this$1._shapeConfig[shape].opacity : this$1._shapeConfig.opacity;
      return typeof value === "function" ? value(d, i) : value;
    };

    var fill = function (d, i) { return ((color(d, i)) + "_" + (opacity(d, i))); };

    nest()
      .key(fill)
      .rollup(function (leaves) { return legendData.push(merge(leaves, this$1._aggs)); })
      .entries(this._colorScale ? data.filter(function (d, i) { return this$1._colorScale(d, i) === undefined; }) : data);

    var hidden = function (d, i) {
      var id = this$1._id(d, i);
      if (id instanceof Array) { id = id[0]; }
      return this$1._hidden.includes(id) || this$1._solo.length && !this$1._solo.includes(id);
    };

    this._legendClass
      .id(fill)
      .align(wide ? "center" : position)
      .direction(wide ? "row" : "column")
      .duration(this._duration)
      .data(legendData.length > 1 || this._colorScale ? legendData : [])
      .height(wide ? this._height - (this._margin.bottom + this._margin.top) : this._height - (this._margin.bottom + this._margin.top + this._padding.bottom + this._padding.top))
      .select(legendGroup)
      .verticalAlign(!wide ? "middle" : position)
      .width(wide ? this._width - (this._margin.left + this._margin.right + this._padding.left + this._padding.right) : this._width - (this._margin.left + this._margin.right))
      .shapeConfig(configPrep.bind(this)(this._shapeConfig, "legend"))
      .config(this._legendConfig)
      .shapeConfig({
        fill: function (d, i) { return hidden(d, i) ? this$1._hiddenColor(d, i) : color(d, i); },
        labelConfig: {
          fontOpacity: function (d, i) { return hidden(d, i) ? this$1._hiddenOpacity(d, i) : 1; }
        },
        opacity: opacity
      })
      .render();

    if (!this._legendConfig.select && legendBounds.height) {
      if (wide) { this._margin[position] += legendBounds.height + this._legendClass.padding() * 2; }
      else { this._margin[position] += legendBounds.width + this._legendClass.padding() * 2; }
    }
  }
}

//# sourceMappingURL=_drawLegend.js.map